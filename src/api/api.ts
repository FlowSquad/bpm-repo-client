/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * OpenAPI definition
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:8081".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AssignmentWithUserNameTO
 */
export interface AssignmentWithUserNameTO {
    /**
     * 
     * @type {string}
     * @memberof AssignmentWithUserNameTO
     */
    bpmnRepositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentWithUserNameTO
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentWithUserNameTO
     */
    roleEnum: AssignmentWithUserNameTO.RoleEnumEnum;
}

/**
 * @export
 * @namespace AssignmentWithUserNameTO
 */
export namespace AssignmentWithUserNameTO {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnumEnum {
        OWNER = <any> 'OWNER',
        ADMIN = <any> 'ADMIN',
        MEMBER = <any> 'MEMBER',
        VIEWER = <any> 'VIEWER'
    }
}
/**
 * 
 * @export
 * @interface BpmnDiagramSVGUploadTO
 */
export interface BpmnDiagramSVGUploadTO {
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramSVGUploadTO
     */
    svgPreview: string;
}
/**
 * 
 * @export
 * @interface BpmnDiagramTO
 */
export interface BpmnDiagramTO {
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramTO
     */
    bpmnDiagramId?: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramTO
     */
    bpmnRepositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramTO
     */
    bpmnDiagramName: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramTO
     */
    bpmnDiagramDescription: string;
    /**
     * 
     * @type {Date}
     * @memberof BpmnDiagramTO
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BpmnDiagramTO
     */
    updatedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramTO
     */
    svgPreview?: string;
}
/**
 * 
 * @export
 * @interface BpmnDiagramUploadTO
 */
export interface BpmnDiagramUploadTO {
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramUploadTO
     */
    bpmnDiagramId?: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramUploadTO
     */
    bpmnDiagramName: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramUploadTO
     */
    bpmnDiagramDescription: string;
}
/**
 * 
 * @export
 * @interface BpmnDiagramVersionTO
 */
export interface BpmnDiagramVersionTO {
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramVersionTO
     */
    bpmnDiagramVersionId?: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramVersionTO
     */
    bpmnDiagramVersionComment?: string;
    /**
     * 
     * @type {number}
     * @memberof BpmnDiagramVersionTO
     */
    bpmnDiagramVersionRelease?: number;
    /**
     * 
     * @type {number}
     * @memberof BpmnDiagramVersionTO
     */
    bpmnDiagramVersionMilestone?: number;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramVersionTO
     */
    bpmnAsXML: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramVersionTO
     */
    saveType: BpmnDiagramVersionTO.SaveTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramVersionTO
     */
    bpmnDiagramId: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramVersionTO
     */
    bpmnRepositoryId: string;
}

/**
 * @export
 * @namespace BpmnDiagramVersionTO
 */
export namespace BpmnDiagramVersionTO {
    /**
     * @export
     * @enum {string}
     */
    export enum SaveTypeEnum {
        RELEASE = <any> 'RELEASE',
        MILESTONE = <any> 'MILESTONE',
        AUTOSAVE = <any> 'AUTOSAVE'
    }
}
/**
 * 
 * @export
 * @interface BpmnDiagramVersionUploadTO
 */
export interface BpmnDiagramVersionUploadTO {
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramVersionUploadTO
     */
    bpmnDiagramVersionComment?: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramVersionUploadTO
     */
    bpmnAsXML?: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnDiagramVersionUploadTO
     */
    saveType?: BpmnDiagramVersionUploadTO.SaveTypeEnum;
}

/**
 * @export
 * @namespace BpmnDiagramVersionUploadTO
 */
export namespace BpmnDiagramVersionUploadTO {
    /**
     * @export
     * @enum {string}
     */
    export enum SaveTypeEnum {
        RELEASE = <any> 'RELEASE',
        MILESTONE = <any> 'MILESTONE',
        AUTOSAVE = <any> 'AUTOSAVE'
    }
}
/**
 * 
 * @export
 * @interface BpmnRepositoryTO
 */
export interface BpmnRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof BpmnRepositoryTO
     */
    bpmnRepositoryId?: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnRepositoryTO
     */
    bpmnRepositoryName: string;
    /**
     * 
     * @type {string}
     * @memberof BpmnRepositoryTO
     */
    bpmnRepositoryDescription: string;
}
/**
 * 
 * @export
 * @interface NewBpmnRepositoryTO
 */
export interface NewBpmnRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof NewBpmnRepositoryTO
     */
    bpmnRepositoryName: string;
    /**
     * 
     * @type {string}
     * @memberof NewBpmnRepositoryTO
     */
    bpmnRepositoryDescription: string;
}
/**
 * 
 * @export
 * @interface UserTO
 */
export interface UserTO {
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    apiKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    email: string;
}
/**
 * 
 * @export
 * @interface UserUpdateTO
 */
export interface UserUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateTO
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateTO
     */
    email?: string;
}
/**
 * AssignmentControllerApi - fetch parameter creator
 * @export
 */
export const AssignmentControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AssignmentWithUserNameTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateUserAssignment(body: AssignmentWithUserNameTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrUpdateUserAssignment.');
            }
            const localVarPath = `/api/assignment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssignmentWithUserNameTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment(repositoryId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling deleteUserAssignment.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserAssignment.');
            }
            const localVarPath = `/api/assignment/{repositoryId}/{userId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/assignment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssignmentControllerApi - functional programming interface
 * @export
 */
export const AssignmentControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AssignmentWithUserNameTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateUserAssignment(body: AssignmentWithUserNameTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssignmentControllerApiFetchParamCreator(configuration).createOrUpdateUserAssignment(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment(repositoryId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssignmentControllerApiFetchParamCreator(configuration).deleteUserAssignment(repositoryId, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssignmentControllerApiFetchParamCreator(configuration).getCurrentUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssignmentControllerApi - factory interface
 * @export
 */
export const AssignmentControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AssignmentWithUserNameTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateUserAssignment(body: AssignmentWithUserNameTO, options?: any) {
            return AssignmentControllerApiFp(configuration).createOrUpdateUserAssignment(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment(repositoryId: string, userId: string, options?: any) {
            return AssignmentControllerApiFp(configuration).deleteUserAssignment(repositoryId, userId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any) {
            return AssignmentControllerApiFp(configuration).getCurrentUser(options)(fetch, basePath);
        },
    };
};

/**
 * AssignmentControllerApi - object-oriented interface
 * @export
 * @class AssignmentControllerApi
 * @extends {BaseAPI}
 */
export class AssignmentControllerApi extends BaseAPI {
    /**
     * 
     * @param {AssignmentWithUserNameTO} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentControllerApi
     */
    public createOrUpdateUserAssignment(body: AssignmentWithUserNameTO, options?: any) {
        return AssignmentControllerApiFp(this.configuration).createOrUpdateUserAssignment(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} repositoryId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentControllerApi
     */
    public deleteUserAssignment(repositoryId: string, userId: string, options?: any) {
        return AssignmentControllerApiFp(this.configuration).deleteUserAssignment(repositoryId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentControllerApi
     */
    public getCurrentUser(options?: any) {
        return AssignmentControllerApiFp(this.configuration).getCurrentUser(options)(this.fetch, this.basePath);
    }

}
/**
 * BpmnDiagramControllerApi - fetch parameter creator
 * @export
 */
export const BpmnDiagramControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BpmnDiagramUploadTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateDiagram(body: BpmnDiagramUploadTO, bpmnRepositoryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrUpdateDiagram.');
            }
            // verify required parameter 'bpmnRepositoryId' is not null or undefined
            if (bpmnRepositoryId === null || bpmnRepositoryId === undefined) {
                throw new RequiredError('bpmnRepositoryId','Required parameter bpmnRepositoryId was null or undefined when calling createOrUpdateDiagram.');
            }
            const localVarPath = `/api/diagram/{bpmnRepositoryId}`
                .replace(`{${"bpmnRepositoryId"}}`, encodeURIComponent(String(bpmnRepositoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BpmnDiagramUploadTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete one Diagram and all of its versions
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiagram(bpmnRepositoryId: string, bpmnDiagramId: string, options: any = {}): FetchArgs {
            // verify required parameter 'bpmnRepositoryId' is not null or undefined
            if (bpmnRepositoryId === null || bpmnRepositoryId === undefined) {
                throw new RequiredError('bpmnRepositoryId','Required parameter bpmnRepositoryId was null or undefined when calling deleteDiagram.');
            }
            // verify required parameter 'bpmnDiagramId' is not null or undefined
            if (bpmnDiagramId === null || bpmnDiagramId === undefined) {
                throw new RequiredError('bpmnDiagramId','Required parameter bpmnDiagramId was null or undefined when calling deleteDiagram.');
            }
            const localVarPath = `/api/diagram/{bpmnRepositoryId}/{bpmnDiagramId}`
                .replace(`{${"bpmnRepositoryId"}}`, encodeURIComponent(String(bpmnRepositoryId)))
                .replace(`{${"bpmnDiagramId"}}`, encodeURIComponent(String(bpmnDiagramId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagramsFromRepo(repositoryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling getDiagramsFromRepo.');
            }
            const localVarPath = `/api/diagram/all/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(options: any = {}): FetchArgs {
            const localVarPath = `/api/diagram/recent10`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleDiagram(bpmnRepositoryId: string, bpmnDiagramId: string, options: any = {}): FetchArgs {
            // verify required parameter 'bpmnRepositoryId' is not null or undefined
            if (bpmnRepositoryId === null || bpmnRepositoryId === undefined) {
                throw new RequiredError('bpmnRepositoryId','Required parameter bpmnRepositoryId was null or undefined when calling getSingleDiagram.');
            }
            // verify required parameter 'bpmnDiagramId' is not null or undefined
            if (bpmnDiagramId === null || bpmnDiagramId === undefined) {
                throw new RequiredError('bpmnDiagramId','Required parameter bpmnDiagramId was null or undefined when calling getSingleDiagram.');
            }
            const localVarPath = `/api/diagram/{bpmnRepositoryId}/{bpmnDiagramId}`
                .replace(`{${"bpmnRepositoryId"}}`, encodeURIComponent(String(bpmnRepositoryId)))
                .replace(`{${"bpmnDiagramId"}}`, encodeURIComponent(String(bpmnDiagramId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred(options: any = {}): FetchArgs {
            const localVarPath = `/api/diagram/starred`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred(bpmnDiagramId: string, options: any = {}): FetchArgs {
            // verify required parameter 'bpmnDiagramId' is not null or undefined
            if (bpmnDiagramId === null || bpmnDiagramId === undefined) {
                throw new RequiredError('bpmnDiagramId','Required parameter bpmnDiagramId was null or undefined when calling setStarred.');
            }
            const localVarPath = `/api/diagram/starred/{bpmnDiagramId}`
                .replace(`{${"bpmnDiagramId"}}`, encodeURIComponent(String(bpmnDiagramId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BpmnDiagramSVGUploadTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreviewSVG(body: BpmnDiagramSVGUploadTO, bpmnRepositoryId: string, bpmnDiagramId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePreviewSVG.');
            }
            // verify required parameter 'bpmnRepositoryId' is not null or undefined
            if (bpmnRepositoryId === null || bpmnRepositoryId === undefined) {
                throw new RequiredError('bpmnRepositoryId','Required parameter bpmnRepositoryId was null or undefined when calling updatePreviewSVG.');
            }
            // verify required parameter 'bpmnDiagramId' is not null or undefined
            if (bpmnDiagramId === null || bpmnDiagramId === undefined) {
                throw new RequiredError('bpmnDiagramId','Required parameter bpmnDiagramId was null or undefined when calling updatePreviewSVG.');
            }
            const localVarPath = `/api/diagram/{bpmnRepositoryId}/{bpmnDiagramId}`
                .replace(`{${"bpmnRepositoryId"}}`, encodeURIComponent(String(bpmnRepositoryId)))
                .replace(`{${"bpmnDiagramId"}}`, encodeURIComponent(String(bpmnDiagramId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BpmnDiagramSVGUploadTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BpmnDiagramControllerApi - functional programming interface
 * @export
 */
export const BpmnDiagramControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BpmnDiagramUploadTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateDiagram(body: BpmnDiagramUploadTO, bpmnRepositoryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BpmnDiagramControllerApiFetchParamCreator(configuration).createOrUpdateDiagram(body, bpmnRepositoryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete one Diagram and all of its versions
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiagram(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BpmnDiagramControllerApiFetchParamCreator(configuration).deleteDiagram(bpmnRepositoryId, bpmnDiagramId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagramsFromRepo(repositoryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BpmnDiagramTO>> {
            const localVarFetchArgs = BpmnDiagramControllerApiFetchParamCreator(configuration).getDiagramsFromRepo(repositoryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BpmnDiagramTO>> {
            const localVarFetchArgs = BpmnDiagramControllerApiFetchParamCreator(configuration).getRecent(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleDiagram(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BpmnDiagramTO> {
            const localVarFetchArgs = BpmnDiagramControllerApiFetchParamCreator(configuration).getSingleDiagram(bpmnRepositoryId, bpmnDiagramId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BpmnDiagramTO>> {
            const localVarFetchArgs = BpmnDiagramControllerApiFetchParamCreator(configuration).getStarred(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred(bpmnDiagramId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BpmnDiagramControllerApiFetchParamCreator(configuration).setStarred(bpmnDiagramId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {BpmnDiagramSVGUploadTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreviewSVG(body: BpmnDiagramSVGUploadTO, bpmnRepositoryId: string, bpmnDiagramId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BpmnDiagramControllerApiFetchParamCreator(configuration).updatePreviewSVG(body, bpmnRepositoryId, bpmnDiagramId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BpmnDiagramControllerApi - factory interface
 * @export
 */
export const BpmnDiagramControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {BpmnDiagramUploadTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateDiagram(body: BpmnDiagramUploadTO, bpmnRepositoryId: string, options?: any) {
            return BpmnDiagramControllerApiFp(configuration).createOrUpdateDiagram(body, bpmnRepositoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete one Diagram and all of its versions
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiagram(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
            return BpmnDiagramControllerApiFp(configuration).deleteDiagram(bpmnRepositoryId, bpmnDiagramId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagramsFromRepo(repositoryId: string, options?: any) {
            return BpmnDiagramControllerApiFp(configuration).getDiagramsFromRepo(repositoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(options?: any) {
            return BpmnDiagramControllerApiFp(configuration).getRecent(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleDiagram(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
            return BpmnDiagramControllerApiFp(configuration).getSingleDiagram(bpmnRepositoryId, bpmnDiagramId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred(options?: any) {
            return BpmnDiagramControllerApiFp(configuration).getStarred(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred(bpmnDiagramId: string, options?: any) {
            return BpmnDiagramControllerApiFp(configuration).setStarred(bpmnDiagramId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {BpmnDiagramSVGUploadTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreviewSVG(body: BpmnDiagramSVGUploadTO, bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
            return BpmnDiagramControllerApiFp(configuration).updatePreviewSVG(body, bpmnRepositoryId, bpmnDiagramId, options)(fetch, basePath);
        },
    };
};

/**
 * BpmnDiagramControllerApi - object-oriented interface
 * @export
 * @class BpmnDiagramControllerApi
 * @extends {BaseAPI}
 */
export class BpmnDiagramControllerApi extends BaseAPI {
    /**
     * 
     * @param {BpmnDiagramUploadTO} body 
     * @param {string} bpmnRepositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramControllerApi
     */
    public createOrUpdateDiagram(body: BpmnDiagramUploadTO, bpmnRepositoryId: string, options?: any) {
        return BpmnDiagramControllerApiFp(this.configuration).createOrUpdateDiagram(body, bpmnRepositoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete one Diagram and all of its versions
     * @param {string} bpmnRepositoryId 
     * @param {string} bpmnDiagramId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramControllerApi
     */
    public deleteDiagram(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
        return BpmnDiagramControllerApiFp(this.configuration).deleteDiagram(bpmnRepositoryId, bpmnDiagramId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramControllerApi
     */
    public getDiagramsFromRepo(repositoryId: string, options?: any) {
        return BpmnDiagramControllerApiFp(this.configuration).getDiagramsFromRepo(repositoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramControllerApi
     */
    public getRecent(options?: any) {
        return BpmnDiagramControllerApiFp(this.configuration).getRecent(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} bpmnRepositoryId 
     * @param {string} bpmnDiagramId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramControllerApi
     */
    public getSingleDiagram(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
        return BpmnDiagramControllerApiFp(this.configuration).getSingleDiagram(bpmnRepositoryId, bpmnDiagramId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramControllerApi
     */
    public getStarred(options?: any) {
        return BpmnDiagramControllerApiFp(this.configuration).getStarred(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} bpmnDiagramId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramControllerApi
     */
    public setStarred(bpmnDiagramId: string, options?: any) {
        return BpmnDiagramControllerApiFp(this.configuration).setStarred(bpmnDiagramId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {BpmnDiagramSVGUploadTO} body 
     * @param {string} bpmnRepositoryId 
     * @param {string} bpmnDiagramId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramControllerApi
     */
    public updatePreviewSVG(body: BpmnDiagramSVGUploadTO, bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
        return BpmnDiagramControllerApiFp(this.configuration).updatePreviewSVG(body, bpmnRepositoryId, bpmnDiagramId, options)(this.fetch, this.basePath);
    }

}
/**
 * BpmnDiagramVersionControllerApi - fetch parameter creator
 * @export
 */
export const BpmnDiagramVersionControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BpmnDiagramVersionUploadTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateVersion(body: BpmnDiagramVersionUploadTO, bpmnRepositoryId: string, bpmnDiagramId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrUpdateVersion.');
            }
            // verify required parameter 'bpmnRepositoryId' is not null or undefined
            if (bpmnRepositoryId === null || bpmnRepositoryId === undefined) {
                throw new RequiredError('bpmnRepositoryId','Required parameter bpmnRepositoryId was null or undefined when calling createOrUpdateVersion.');
            }
            // verify required parameter 'bpmnDiagramId' is not null or undefined
            if (bpmnDiagramId === null || bpmnDiagramId === undefined) {
                throw new RequiredError('bpmnDiagramId','Required parameter bpmnDiagramId was null or undefined when calling createOrUpdateVersion.');
            }
            const localVarPath = `/api/version/{bpmnRepositoryId}/{bpmnDiagramId}`
                .replace(`{${"bpmnRepositoryId"}}`, encodeURIComponent(String(bpmnRepositoryId)))
                .replace(`{${"bpmnDiagramId"}}`, encodeURIComponent(String(bpmnDiagramId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BpmnDiagramVersionUploadTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions(bpmnRepositoryId: string, bpmnDiagramId: string, options: any = {}): FetchArgs {
            // verify required parameter 'bpmnRepositoryId' is not null or undefined
            if (bpmnRepositoryId === null || bpmnRepositoryId === undefined) {
                throw new RequiredError('bpmnRepositoryId','Required parameter bpmnRepositoryId was null or undefined when calling getAllVersions.');
            }
            // verify required parameter 'bpmnDiagramId' is not null or undefined
            if (bpmnDiagramId === null || bpmnDiagramId === undefined) {
                throw new RequiredError('bpmnDiagramId','Required parameter bpmnDiagramId was null or undefined when calling getAllVersions.');
            }
            const localVarPath = `/api/version/{bpmnRepositoryId}/{bpmnDiagramId}/all`
                .replace(`{${"bpmnRepositoryId"}}`, encodeURIComponent(String(bpmnRepositoryId)))
                .replace(`{${"bpmnDiagramId"}}`, encodeURIComponent(String(bpmnDiagramId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the latest version of the requested diagram
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestVersion(bpmnRepositoryId: string, bpmnDiagramId: string, options: any = {}): FetchArgs {
            // verify required parameter 'bpmnRepositoryId' is not null or undefined
            if (bpmnRepositoryId === null || bpmnRepositoryId === undefined) {
                throw new RequiredError('bpmnRepositoryId','Required parameter bpmnRepositoryId was null or undefined when calling getLatestVersion.');
            }
            // verify required parameter 'bpmnDiagramId' is not null or undefined
            if (bpmnDiagramId === null || bpmnDiagramId === undefined) {
                throw new RequiredError('bpmnDiagramId','Required parameter bpmnDiagramId was null or undefined when calling getLatestVersion.');
            }
            const localVarPath = `/api/version/{bpmnRepositoryId}/{bpmnDiagramId}/latest`
                .replace(`{${"bpmnRepositoryId"}}`, encodeURIComponent(String(bpmnRepositoryId)))
                .replace(`{${"bpmnDiagramId"}}`, encodeURIComponent(String(bpmnDiagramId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {string} bpmnDiagramVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVersion(bpmnRepositoryId: string, bpmnDiagramId: string, bpmnDiagramVersionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'bpmnRepositoryId' is not null or undefined
            if (bpmnRepositoryId === null || bpmnRepositoryId === undefined) {
                throw new RequiredError('bpmnRepositoryId','Required parameter bpmnRepositoryId was null or undefined when calling getSingleVersion.');
            }
            // verify required parameter 'bpmnDiagramId' is not null or undefined
            if (bpmnDiagramId === null || bpmnDiagramId === undefined) {
                throw new RequiredError('bpmnDiagramId','Required parameter bpmnDiagramId was null or undefined when calling getSingleVersion.');
            }
            // verify required parameter 'bpmnDiagramVersionId' is not null or undefined
            if (bpmnDiagramVersionId === null || bpmnDiagramVersionId === undefined) {
                throw new RequiredError('bpmnDiagramVersionId','Required parameter bpmnDiagramVersionId was null or undefined when calling getSingleVersion.');
            }
            const localVarPath = `/api/version/{bpmnRepositoryId}/{bpmnDiagramId}/{bpmnDiagramVersionId}`
                .replace(`{${"bpmnRepositoryId"}}`, encodeURIComponent(String(bpmnRepositoryId)))
                .replace(`{${"bpmnDiagramId"}}`, encodeURIComponent(String(bpmnDiagramId)))
                .replace(`{${"bpmnDiagramVersionId"}}`, encodeURIComponent(String(bpmnDiagramVersionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BpmnDiagramVersionControllerApi - functional programming interface
 * @export
 */
export const BpmnDiagramVersionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BpmnDiagramVersionUploadTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateVersion(body: BpmnDiagramVersionUploadTO, bpmnRepositoryId: string, bpmnDiagramId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BpmnDiagramVersionControllerApiFetchParamCreator(configuration).createOrUpdateVersion(body, bpmnRepositoryId, bpmnDiagramId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BpmnDiagramVersionTO>> {
            const localVarFetchArgs = BpmnDiagramVersionControllerApiFetchParamCreator(configuration).getAllVersions(bpmnRepositoryId, bpmnDiagramId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return the latest version of the requested diagram
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestVersion(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BpmnDiagramVersionTO> {
            const localVarFetchArgs = BpmnDiagramVersionControllerApiFetchParamCreator(configuration).getLatestVersion(bpmnRepositoryId, bpmnDiagramId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {string} bpmnDiagramVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVersion(bpmnRepositoryId: string, bpmnDiagramId: string, bpmnDiagramVersionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BpmnDiagramVersionTO> {
            const localVarFetchArgs = BpmnDiagramVersionControllerApiFetchParamCreator(configuration).getSingleVersion(bpmnRepositoryId, bpmnDiagramId, bpmnDiagramVersionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BpmnDiagramVersionControllerApi - factory interface
 * @export
 */
export const BpmnDiagramVersionControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {BpmnDiagramVersionUploadTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateVersion(body: BpmnDiagramVersionUploadTO, bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
            return BpmnDiagramVersionControllerApiFp(configuration).createOrUpdateVersion(body, bpmnRepositoryId, bpmnDiagramId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
            return BpmnDiagramVersionControllerApiFp(configuration).getAllVersions(bpmnRepositoryId, bpmnDiagramId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return the latest version of the requested diagram
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestVersion(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
            return BpmnDiagramVersionControllerApiFp(configuration).getLatestVersion(bpmnRepositoryId, bpmnDiagramId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} bpmnRepositoryId 
         * @param {string} bpmnDiagramId 
         * @param {string} bpmnDiagramVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVersion(bpmnRepositoryId: string, bpmnDiagramId: string, bpmnDiagramVersionId: string, options?: any) {
            return BpmnDiagramVersionControllerApiFp(configuration).getSingleVersion(bpmnRepositoryId, bpmnDiagramId, bpmnDiagramVersionId, options)(fetch, basePath);
        },
    };
};

/**
 * BpmnDiagramVersionControllerApi - object-oriented interface
 * @export
 * @class BpmnDiagramVersionControllerApi
 * @extends {BaseAPI}
 */
export class BpmnDiagramVersionControllerApi extends BaseAPI {
    /**
     * 
     * @param {BpmnDiagramVersionUploadTO} body 
     * @param {string} bpmnRepositoryId 
     * @param {string} bpmnDiagramId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramVersionControllerApi
     */
    public createOrUpdateVersion(body: BpmnDiagramVersionUploadTO, bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
        return BpmnDiagramVersionControllerApiFp(this.configuration).createOrUpdateVersion(body, bpmnRepositoryId, bpmnDiagramId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} bpmnRepositoryId 
     * @param {string} bpmnDiagramId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramVersionControllerApi
     */
    public getAllVersions(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
        return BpmnDiagramVersionControllerApiFp(this.configuration).getAllVersions(bpmnRepositoryId, bpmnDiagramId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return the latest version of the requested diagram
     * @param {string} bpmnRepositoryId 
     * @param {string} bpmnDiagramId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramVersionControllerApi
     */
    public getLatestVersion(bpmnRepositoryId: string, bpmnDiagramId: string, options?: any) {
        return BpmnDiagramVersionControllerApiFp(this.configuration).getLatestVersion(bpmnRepositoryId, bpmnDiagramId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} bpmnRepositoryId 
     * @param {string} bpmnDiagramId 
     * @param {string} bpmnDiagramVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnDiagramVersionControllerApi
     */
    public getSingleVersion(bpmnRepositoryId: string, bpmnDiagramId: string, bpmnDiagramVersionId: string, options?: any) {
        return BpmnDiagramVersionControllerApiFp(this.configuration).getSingleVersion(bpmnRepositoryId, bpmnDiagramId, bpmnDiagramVersionId, options)(this.fetch, this.basePath);
    }

}
/**
 * BpmnRepositoryControllerApi - fetch parameter creator
 * @export
 */
export const BpmnRepositoryControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewBpmnRepositoryTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(body: NewBpmnRepositoryTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRepository.');
            }
            const localVarPath = `/api/bpmnrepo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewBpmnRepositoryTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repositoryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling deleteRepository.');
            }
            const localVarPath = `/api/bpmnrepo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories(options: any = {}): FetchArgs {
            const localVarPath = `/api/bpmnrepo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository(repositoryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling getSingleRepository.');
            }
            const localVarPath = `/api/bpmnrepo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Repository
         * @param {NewBpmnRepositoryTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(body: NewBpmnRepositoryTO, bpmnRepositoryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRepository.');
            }
            // verify required parameter 'bpmnRepositoryId' is not null or undefined
            if (bpmnRepositoryId === null || bpmnRepositoryId === undefined) {
                throw new RequiredError('bpmnRepositoryId','Required parameter bpmnRepositoryId was null or undefined when calling updateRepository.');
            }
            const localVarPath = `/api/bpmnrepo/{bpmnRepositoryId}`
                .replace(`{${"bpmnRepositoryId"}}`, encodeURIComponent(String(bpmnRepositoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewBpmnRepositoryTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BpmnRepositoryControllerApi - functional programming interface
 * @export
 */
export const BpmnRepositoryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewBpmnRepositoryTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(body: NewBpmnRepositoryTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BpmnRepositoryControllerApiFetchParamCreator(configuration).createRepository(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repositoryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BpmnRepositoryControllerApiFetchParamCreator(configuration).deleteRepository(repositoryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BpmnRepositoryTO>> {
            const localVarFetchArgs = BpmnRepositoryControllerApiFetchParamCreator(configuration).getAllRepositories(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository(repositoryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BpmnRepositoryTO> {
            const localVarFetchArgs = BpmnRepositoryControllerApiFetchParamCreator(configuration).getSingleRepository(repositoryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a Repository
         * @param {NewBpmnRepositoryTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(body: NewBpmnRepositoryTO, bpmnRepositoryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BpmnRepositoryControllerApiFetchParamCreator(configuration).updateRepository(body, bpmnRepositoryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BpmnRepositoryControllerApi - factory interface
 * @export
 */
export const BpmnRepositoryControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewBpmnRepositoryTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(body: NewBpmnRepositoryTO, options?: any) {
            return BpmnRepositoryControllerApiFp(configuration).createRepository(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repositoryId: string, options?: any) {
            return BpmnRepositoryControllerApiFp(configuration).deleteRepository(repositoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories(options?: any) {
            return BpmnRepositoryControllerApiFp(configuration).getAllRepositories(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository(repositoryId: string, options?: any) {
            return BpmnRepositoryControllerApiFp(configuration).getSingleRepository(repositoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a Repository
         * @param {NewBpmnRepositoryTO} body 
         * @param {string} bpmnRepositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(body: NewBpmnRepositoryTO, bpmnRepositoryId: string, options?: any) {
            return BpmnRepositoryControllerApiFp(configuration).updateRepository(body, bpmnRepositoryId, options)(fetch, basePath);
        },
    };
};

/**
 * BpmnRepositoryControllerApi - object-oriented interface
 * @export
 * @class BpmnRepositoryControllerApi
 * @extends {BaseAPI}
 */
export class BpmnRepositoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Repository
     * @param {NewBpmnRepositoryTO} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnRepositoryControllerApi
     */
    public createRepository(body: NewBpmnRepositoryTO, options?: any) {
        return BpmnRepositoryControllerApiFp(this.configuration).createRepository(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a Repository if you own it
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnRepositoryControllerApi
     */
    public deleteRepository(repositoryId: string, options?: any) {
        return BpmnRepositoryControllerApiFp(this.configuration).deleteRepository(repositoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all Repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnRepositoryControllerApi
     */
    public getAllRepositories(options?: any) {
        return BpmnRepositoryControllerApiFp(this.configuration).getAllRepositories(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a single Repository by providing its ID
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnRepositoryControllerApi
     */
    public getSingleRepository(repositoryId: string, options?: any) {
        return BpmnRepositoryControllerApiFp(this.configuration).getSingleRepository(repositoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a Repository
     * @param {NewBpmnRepositoryTO} body 
     * @param {string} bpmnRepositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BpmnRepositoryControllerApi
     */
    public updateRepository(body: NewBpmnRepositoryTO, bpmnRepositoryId: string, options?: any) {
        return BpmnRepositoryControllerApiFp(this.configuration).updateRepository(body, bpmnRepositoryId, options)(this.fetch, this.basePath);
    }

}
/**
 * UserControllerApi - fetch parameter creator
 * @export
 */
export const UserControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: UserTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/api/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(options: any = {}): FetchArgs {
            const localVarPath = `/api/user/apiKey`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserUpdateTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UserUpdateTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            const localVarPath = `/api/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserUpdateTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: UserTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).createUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserTO> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getApiKey(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UserUpdateTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UserUpdateTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).updateUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {UserTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: UserTO, options?: any) {
            return UserControllerApiFp(configuration).createUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(options?: any) {
            return UserControllerApiFp(configuration).getApiKey(options)(fetch, basePath);
        },
        /**
         * 
         * @param {UserUpdateTO} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UserUpdateTO, options?: any) {
            return UserControllerApiFp(configuration).updateUser(body, options)(fetch, basePath);
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @param {UserTO} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public createUser(body: UserTO, options?: any) {
        return UserControllerApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getApiKey(options?: any) {
        return UserControllerApiFp(this.configuration).getApiKey(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UserUpdateTO} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateUser(body: UserUpdateTO, options?: any) {
        return UserControllerApiFp(this.configuration).updateUser(body, options)(this.fetch, this.basePath);
    }

}
