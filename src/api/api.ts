/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * version of an artifact, contains the file and information about deployments
 * @export
 * @interface ArtifactMilestoneTO
 */
export interface ArtifactMilestoneTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtifactMilestoneTO
     */
    milestone: number;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    file: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    artifactId: string;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactMilestoneTO
     */
    latestMilestone: boolean;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    repositoryId: string;
    /**
     * 
     * @type {Array<DeploymentTO>}
     * @memberof ArtifactMilestoneTO
     */
    deployments: Array<DeploymentTO>;
}
/**
 * Client created Object for updating accessible properties of a version
 * @export
 * @interface ArtifactMilestoneUpdateTO
 */
export interface ArtifactMilestoneUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUpdateTO
     */
    milestoneId?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUpdateTO
     */
    file?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUpdateTO
     */
    comment?: string;
}
/**
 * Client created object for uploading a version from the client
 * @export
 * @interface ArtifactMilestoneUploadTO
 */
export interface ArtifactMilestoneUploadTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUploadTO
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUploadTO
     */
    file?: string;
}
/**
 * Containing metadata for an artifact
 * @export
 * @interface ArtifactTO
 */
export interface ArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    fileType: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    lockedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    lockedUntil?: string;
}
/**
 * Specifies properties for supported file types
 * @export
 * @interface ArtifactTypeTO
 */
export interface ArtifactTypeTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    fileExtension: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    svgIcon: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactTypeTO
     */
    editable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactTypeTO
     */
    deployable?: boolean;
}
/**
 * Client created object for updating accessible properties of an artifact
 * @export
 * @interface ArtifactUpdateTO
 */
export interface ArtifactUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    fileType?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    file?: string;
}
/**
 * Containing information about a user-repository relation
 * @export
 * @interface AssignmentTO
 */
export interface AssignmentTO {
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    role: AssignmentTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AssignmentTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Containing information about the deployment of an artifact
 * @export
 * @interface DeploymentTO
 */
export interface DeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    target: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    status: DeploymentTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    user: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    timestamp: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DeploymentTOStatusEnum {
    Pending = 'PENDING',
    Success = 'SUCCESS',
    Error = 'ERROR'
}

/**
 * Client created object for creating a new artifact
 * @export
 * @interface NewArtifactTO
 */
export interface NewArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    fileType: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    file?: string;
}
/**
 * Client created object containing the deployment target and artifact(-version) id(-s) for creating a new deployment
 * @export
 * @interface NewDeploymentTO
 */
export interface NewDeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    milestoneId: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    target: string;
}
/**
 * Client created object for creating a new repository
 * @export
 * @interface NewRepositoryTO
 */
export interface NewRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    description: string;
}
/**
 * Containing information about a repository
 * @export
 * @interface RepositoryTO
 */
export interface RepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    existingArtifacts: number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    assignedUsers: number;
}
/**
 * 
 * @export
 * @interface RepositoryUpdateTO
 */
export interface RepositoryUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    description: string;
}
/**
 * 
 * @export
 * @interface ShareWithRepositoryTO
 */
export interface ShareWithRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    role: ShareWithRepositoryTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareWithRepositoryTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface SharedRepositoryTO
 */
export interface SharedRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    role: SharedRepositoryTORoleEnum;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    artifactName?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    repositoryName?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SharedRepositoryTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Containing all information about an user
 * @export
 * @interface UserInfoTO
 */
export interface UserInfoTO {
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    id: string;
}
/**
 * Simplified user object only containing username
 * @export
 * @interface UserTO
 */
export interface UserTO {
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    username: string;
}

/**
 * ArtifactApi - axios parameter creator
 * @export
 */
export const ArtifactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Copy file to other repository
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository: async (repositoryId: string, artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling copyToRepository.');
            }
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling copyToRepository.');
            }
            // verify required parameter 'artifactUpdateTO' is not null or undefined
            if (artifactUpdateTO === null || artifactUpdateTO === undefined) {
                throw new RequiredError('artifactUpdateTO','Required parameter artifactUpdateTO was null or undefined when calling copyToRepository.');
            }
            const localVarPath = `/api/artifact/copy/{repositoryId}/{artifactId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof artifactUpdateTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(artifactUpdateTO !== undefined ? artifactUpdateTO : {})
                : (artifactUpdateTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an artifact
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact: async (repositoryId: string, newArtifactTO: NewArtifactTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling createArtifact.');
            }
            // verify required parameter 'newArtifactTO' is not null or undefined
            if (newArtifactTO === null || newArtifactTO === undefined) {
                throw new RequiredError('newArtifactTO','Required parameter newArtifactTO was null or undefined when calling createArtifact.');
            }
            const localVarPath = `/api/artifact/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof newArtifactTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(newArtifactTO !== undefined ? newArtifactTO : {})
                : (newArtifactTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling deleteArtifact.');
            }
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all available file types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get single artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling getArtifact.');
            }
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all artifacts of the given repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling getArtifactsFromRepo.');
            }
            const localVarPath = `/api/artifact/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all artifacts of a specific type from a repository
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType: async (repositoryId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling getByRepoIdAndType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getByRepoIdAndType.');
            }
            const localVarPath = `/api/artifact/{repositoryId}/{type}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recent artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all starred artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/starred`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling lockArtifact.');
            }
            const localVarPath = `/api/artifact/{artifactId}/lock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search artifacts by title.
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts: async (typedTitle: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedTitle' is not null or undefined
            if (typedTitle === null || typedTitle === undefined) {
                throw new RequiredError('typedTitle','Required parameter typedTitle was null or undefined when calling searchArtifacts.');
            }
            const localVarPath = `/api/artifact/search/{typedTitle}`
                .replace(`{${"typedTitle"}}`, encodeURIComponent(String(typedTitle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inverts the star-status (favorite-status) of an artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling setStarred.');
            }
            const localVarPath = `/api/artifact/starred/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlock a artifact after editing is finished
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling unlockArtifact.');
            }
            const localVarPath = `/api/artifact/{artifactId}/unlock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an artifact
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact: async (artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling updateArtifact.');
            }
            // verify required parameter 'artifactUpdateTO' is not null or undefined
            if (artifactUpdateTO === null || artifactUpdateTO === undefined) {
                throw new RequiredError('artifactUpdateTO','Required parameter artifactUpdateTO was null or undefined when calling updateArtifact.');
            }
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof artifactUpdateTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(artifactUpdateTO !== undefined ? artifactUpdateTO : {})
                : (artifactUpdateTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactApi - functional programming interface
 * @export
 */
export const ArtifactApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Copy file to other repository
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyToRepository(repositoryId: string, artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).copyToRepository(repositoryId, artifactId, artifactUpdateTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create an artifact
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).createArtifact(repositoryId, newArtifactTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).deleteArtifact(artifactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all available file types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFileTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTypeTO>>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).getAllFileTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get single artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).getArtifact(artifactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all artifacts of the given repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsFromRepo(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).getArtifactsFromRepo(repositoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all artifacts of a specific type from a repository
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByRepoIdAndType(repositoryId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).getByRepoIdAndType(repositoryId, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get recent artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).getRecent(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns all starred artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStarred(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).getStarred(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).lockArtifact(artifactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search artifacts by title.
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtifacts(typedTitle: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).searchArtifacts(typedTitle, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Inverts the star-status (favorite-status) of an artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setStarred(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).setStarred(artifactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unlock a artifact after editing is finished
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).unlockArtifact(artifactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update an artifact
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await ArtifactApiAxiosParamCreator(configuration).updateArtifact(artifactId, artifactUpdateTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArtifactApi - factory interface
 * @export
 */
export const ArtifactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Copy file to other repository
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository(repositoryId: string, artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): AxiosPromise<ArtifactTO> {
            return ArtifactApiFp(configuration).copyToRepository(repositoryId, artifactId, artifactUpdateTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an artifact
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): AxiosPromise<ArtifactTO> {
            return ArtifactApiFp(configuration).createArtifact(repositoryId, newArtifactTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(artifactId: string, options?: any): AxiosPromise<void> {
            return ArtifactApiFp(configuration).deleteArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all available file types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes(options?: any): AxiosPromise<Array<ArtifactTypeTO>> {
            return ArtifactApiFp(configuration).getAllFileTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get single artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return ArtifactApiFp(configuration).getArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all artifacts of the given repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo(repositoryId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return ArtifactApiFp(configuration).getArtifactsFromRepo(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all artifacts of a specific type from a repository
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType(repositoryId: string, type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return ArtifactApiFp(configuration).getByRepoIdAndType(repositoryId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recent artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return ArtifactApiFp(configuration).getRecent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all starred artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return ArtifactApiFp(configuration).getStarred(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return ArtifactApiFp(configuration).lockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search artifacts by title.
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts(typedTitle: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return ArtifactApiFp(configuration).searchArtifacts(typedTitle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inverts the star-status (favorite-status) of an artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred(artifactId: string, options?: any): AxiosPromise<void> {
            return ArtifactApiFp(configuration).setStarred(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlock a artifact after editing is finished
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return ArtifactApiFp(configuration).unlockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an artifact
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): AxiosPromise<ArtifactTO> {
            return ArtifactApiFp(configuration).updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactApi - object-oriented interface
 * @export
 * @class ArtifactApi
 * @extends {BaseAPI}
 */
export class ArtifactApi extends BaseAPI {
    /**
     * 
     * @summary Copy file to other repository
     * @param {string} repositoryId 
     * @param {string} artifactId 
     * @param {ArtifactUpdateTO} artifactUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public copyToRepository(repositoryId: string, artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any) {
        return ArtifactApiFp(this.configuration).copyToRepository(repositoryId, artifactId, artifactUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an artifact
     * @param {string} repositoryId 
     * @param {NewArtifactTO} newArtifactTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any) {
        return ArtifactApiFp(this.configuration).createArtifact(repositoryId, newArtifactTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete one Artifact and all of its versions
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public deleteArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).deleteArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all available file types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getAllFileTypes(options?: any) {
        return ArtifactApiFp(this.configuration).getAllFileTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get single artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all artifacts of the given repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsFromRepo(repositoryId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifactsFromRepo(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all artifacts of a specific type from a repository
     * @param {string} repositoryId 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getByRepoIdAndType(repositoryId: string, type: string, options?: any) {
        return ArtifactApiFp(this.configuration).getByRepoIdAndType(repositoryId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recent artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getRecent(options?: any) {
        return ArtifactApiFp(this.configuration).getRecent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all starred artifacts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getStarred(options?: any) {
        return ArtifactApiFp(this.configuration).getStarred(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public lockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).lockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search artifacts by title.
     * @param {string} typedTitle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public searchArtifacts(typedTitle: string, options?: any) {
        return ArtifactApiFp(this.configuration).searchArtifacts(typedTitle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inverts the star-status (favorite-status) of an artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public setStarred(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).setStarred(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlock a artifact after editing is finished
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public unlockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).unlockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an artifact
     * @param {string} artifactId 
     * @param {ArtifactUpdateTO} artifactUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any) {
        return ArtifactApiFp(this.configuration).updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploy artifact milestone
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMilestone: async (newDeploymentTO: NewDeploymentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newDeploymentTO' is not null or undefined
            if (newDeploymentTO === null || newDeploymentTO === undefined) {
                throw new RequiredError('newDeploymentTO','Required parameter newDeploymentTO was null or undefined when calling deployMilestone.');
            }
            const localVarPath = `/api/deploy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof newDeploymentTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(newDeploymentTO !== undefined ? newDeploymentTO : {})
                : (newDeploymentTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploy multiple milestones
         * @param {Array<NewDeploymentTO>} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMultipleMilestones: async (newDeploymentTO: Array<NewDeploymentTO>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newDeploymentTO' is not null or undefined
            if (newDeploymentTO === null || newDeploymentTO === undefined) {
                throw new RequiredError('newDeploymentTO','Required parameter newDeploymentTO was null or undefined when calling deployMultipleMilestones.');
            }
            const localVarPath = `/api/deploy/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof newDeploymentTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(newDeploymentTO !== undefined ? newDeploymentTO : {})
                : (newDeploymentTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/deploy/target`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all deployments of a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentsFromRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling getAllDeploymentsFromRepository.');
            }
            const localVarPath = `/api/deploy/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploy artifact milestone
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployMilestone(newDeploymentTO: NewDeploymentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await DeploymentApiAxiosParamCreator(configuration).deployMilestone(newDeploymentTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deploy multiple milestones
         * @param {Array<NewDeploymentTO>} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployMultipleMilestones(newDeploymentTO: Array<NewDeploymentTO>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactMilestoneTO>>> {
            const localVarAxiosArgs = await DeploymentApiAxiosParamCreator(configuration).deployMultipleMilestones(newDeploymentTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDeploymentTargets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await DeploymentApiAxiosParamCreator(configuration).getAllDeploymentTargets(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all deployments of a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDeploymentsFromRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentTO>>> {
            const localVarAxiosArgs = await DeploymentApiAxiosParamCreator(configuration).getAllDeploymentsFromRepository(repositoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deploy artifact milestone
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMilestone(newDeploymentTO: NewDeploymentTO, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return DeploymentApiFp(configuration).deployMilestone(newDeploymentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploy multiple milestones
         * @param {Array<NewDeploymentTO>} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMultipleMilestones(newDeploymentTO: Array<NewDeploymentTO>, options?: any): AxiosPromise<Array<ArtifactMilestoneTO>> {
            return DeploymentApiFp(configuration).deployMultipleMilestones(newDeploymentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets(options?: any): AxiosPromise<Array<string>> {
            return DeploymentApiFp(configuration).getAllDeploymentTargets(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all deployments of a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentsFromRepository(repositoryId: string, options?: any): AxiosPromise<Array<DeploymentTO>> {
            return DeploymentApiFp(configuration).getAllDeploymentsFromRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @summary Deploy artifact milestone
     * @param {NewDeploymentTO} newDeploymentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployMilestone(newDeploymentTO: NewDeploymentTO, options?: any) {
        return DeploymentApiFp(this.configuration).deployMilestone(newDeploymentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deploy multiple milestones
     * @param {Array<NewDeploymentTO>} newDeploymentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployMultipleMilestones(newDeploymentTO: Array<NewDeploymentTO>, options?: any) {
        return DeploymentApiFp(this.configuration).deployMultipleMilestones(newDeploymentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all available deployment targets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getAllDeploymentTargets(options?: any) {
        return DeploymentApiFp(this.configuration).getAllDeploymentTargets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all deployments of a repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getAllDeploymentsFromRepository(repositoryId: string, options?: any) {
        return DeploymentApiFp(this.configuration).getAllDeploymentsFromRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MilestoneApi - axios parameter creator
 * @export
 */
export const MilestoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {string} artifactId 
         * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMilestone: async (artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling createMilestone.');
            }
            // verify required parameter 'artifactMilestoneUploadTO' is not null or undefined
            if (artifactMilestoneUploadTO === null || artifactMilestoneUploadTO === undefined) {
                throw new RequiredError('artifactMilestoneUploadTO','Required parameter artifactMilestoneUploadTO was null or undefined when calling createMilestone.');
            }
            const localVarPath = `/api/milestone/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof artifactMilestoneUploadTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(artifactMilestoneUploadTO !== undefined ? artifactMilestoneUploadTO : {})
                : (artifactMilestoneUploadTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a specific milestone
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMilestone: async (artifactId: string, milestoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling downloadMilestone.');
            }
            // verify required parameter 'milestoneId' is not null or undefined
            if (milestoneId === null || milestoneId === undefined) {
                throw new RequiredError('milestoneId','Required parameter milestoneId was null or undefined when calling downloadMilestone.');
            }
            const localVarPath = `/api/milestone/{artifactId}/{milestoneId}/download`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"milestoneId"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get milestones by providing deploymentIds
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllByDeploymentIds: async (requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling getAllByDeploymentIds.');
            }
            const localVarPath = `/api/milestone/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof requestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(requestBody !== undefined ? requestBody : {})
                : (requestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all milestones of the artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMilestones: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling getAllMilestones.');
            }
            const localVarPath = `/api/milestone/{artifactId}/milestone`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {number} milestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByMilestoneNumber: async (artifactId: string, milestone: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling getByMilestoneNumber.');
            }
            // verify required parameter 'milestone' is not null or undefined
            if (milestone === null || milestone === undefined) {
                throw new RequiredError('milestone','Required parameter milestone was null or undefined when calling getByMilestoneNumber.');
            }
            const localVarPath = `/api/milestone/{artifactId}/milestoneNumber/{milestone}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"milestone"}}`, encodeURIComponent(String(milestone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the latest milestone of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMilestone: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling getLatestMilestone.');
            }
            const localVarPath = `/api/milestone/{artifactId}/milestone/latest`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMilestone: async (artifactId: string, milestoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling getMilestone.');
            }
            // verify required parameter 'milestoneId' is not null or undefined
            if (milestoneId === null || milestoneId === undefined) {
                throw new RequiredError('milestoneId','Required parameter milestoneId was null or undefined when calling getMilestone.');
            }
            const localVarPath = `/api/milestone/{artifactId}/milestone/{milestoneId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"milestoneId"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMilestone: async (artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactMilestoneUpdateTO' is not null or undefined
            if (artifactMilestoneUpdateTO === null || artifactMilestoneUpdateTO === undefined) {
                throw new RequiredError('artifactMilestoneUpdateTO','Required parameter artifactMilestoneUpdateTO was null or undefined when calling updateMilestone.');
            }
            const localVarPath = `/api/milestone/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof artifactMilestoneUpdateTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(artifactMilestoneUpdateTO !== undefined ? artifactMilestoneUpdateTO : {})
                : (artifactMilestoneUpdateTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MilestoneApi - functional programming interface
 * @export
 */
export const MilestoneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {string} artifactId 
         * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMilestone(artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await MilestoneApiAxiosParamCreator(configuration).createMilestone(artifactId, artifactMilestoneUploadTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Download a specific milestone
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMilestone(artifactId: string, milestoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await MilestoneApiAxiosParamCreator(configuration).downloadMilestone(artifactId, milestoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get milestones by providing deploymentIds
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllByDeploymentIds(requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactMilestoneTO>>> {
            const localVarAxiosArgs = await MilestoneApiAxiosParamCreator(configuration).getAllByDeploymentIds(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all milestones of the artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMilestones(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactMilestoneTO>>> {
            const localVarAxiosArgs = await MilestoneApiAxiosParamCreator(configuration).getAllMilestones(artifactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {number} milestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByMilestoneNumber(artifactId: string, milestone: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await MilestoneApiAxiosParamCreator(configuration).getByMilestoneNumber(artifactId, milestone, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return the latest milestone of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestMilestone(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await MilestoneApiAxiosParamCreator(configuration).getLatestMilestone(artifactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a specific milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMilestone(artifactId: string, milestoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await MilestoneApiAxiosParamCreator(configuration).getMilestone(artifactId, milestoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMilestone(artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await MilestoneApiAxiosParamCreator(configuration).updateMilestone(artifactMilestoneUpdateTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MilestoneApi - factory interface
 * @export
 */
export const MilestoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {string} artifactId 
         * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMilestone(artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return MilestoneApiFp(configuration).createMilestone(artifactId, artifactMilestoneUploadTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a specific milestone
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMilestone(artifactId: string, milestoneId: string, options?: any): AxiosPromise<any> {
            return MilestoneApiFp(configuration).downloadMilestone(artifactId, milestoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get milestones by providing deploymentIds
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllByDeploymentIds(requestBody: Array<string>, options?: any): AxiosPromise<Array<ArtifactMilestoneTO>> {
            return MilestoneApiFp(configuration).getAllByDeploymentIds(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all milestones of the artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMilestones(artifactId: string, options?: any): AxiosPromise<Array<ArtifactMilestoneTO>> {
            return MilestoneApiFp(configuration).getAllMilestones(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {number} milestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByMilestoneNumber(artifactId: string, milestone: number, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return MilestoneApiFp(configuration).getByMilestoneNumber(artifactId, milestone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the latest milestone of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMilestone(artifactId: string, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return MilestoneApiFp(configuration).getLatestMilestone(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMilestone(artifactId: string, milestoneId: string, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return MilestoneApiFp(configuration).getMilestone(artifactId, milestoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMilestone(artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return MilestoneApiFp(configuration).updateMilestone(artifactMilestoneUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MilestoneApi - object-oriented interface
 * @export
 * @class MilestoneApi
 * @extends {BaseAPI}
 */
export class MilestoneApi extends BaseAPI {
    /**
     * 
     * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
     * @param {string} artifactId 
     * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public createMilestone(artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options?: any) {
        return MilestoneApiFp(this.configuration).createMilestone(artifactId, artifactMilestoneUploadTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a specific milestone
     * @param {string} artifactId 
     * @param {string} milestoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public downloadMilestone(artifactId: string, milestoneId: string, options?: any) {
        return MilestoneApiFp(this.configuration).downloadMilestone(artifactId, milestoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get milestones by providing deploymentIds
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getAllByDeploymentIds(requestBody: Array<string>, options?: any) {
        return MilestoneApiFp(this.configuration).getAllByDeploymentIds(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all milestones of the artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getAllMilestones(artifactId: string, options?: any) {
        return MilestoneApiFp(this.configuration).getAllMilestones(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
     * @param {string} artifactId 
     * @param {number} milestone 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getByMilestoneNumber(artifactId: string, milestone: number, options?: any) {
        return MilestoneApiFp(this.configuration).getByMilestoneNumber(artifactId, milestone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the latest milestone of the requested artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getLatestMilestone(artifactId: string, options?: any) {
        return MilestoneApiFp(this.configuration).getLatestMilestone(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific milestone, read-permission granted even if Artifact is locked
     * @param {string} artifactId 
     * @param {string} milestoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getMilestone(artifactId: string, milestoneId: string, options?: any) {
        return MilestoneApiFp(this.configuration).getMilestone(artifactId, milestoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
     * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public updateMilestone(artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options?: any) {
        return MilestoneApiFp(this.configuration).updateMilestone(artifactMilestoneUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepoAssignmentApi - axios parameter creator
 * @export
 */
export const RepoAssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAssignment: async (assignmentTO: AssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentTO' is not null or undefined
            if (assignmentTO === null || assignmentTO === undefined) {
                throw new RequiredError('assignmentTO','Required parameter assignmentTO was null or undefined when calling createUserAssignment.');
            }
            const localVarPath = `/api/repoAssignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof assignmentTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(assignmentTO !== undefined ? assignmentTO : {})
                : (assignmentTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user assignment to repository
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment: async (repositoryId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling deleteUserAssignment.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserAssignment.');
            }
            const localVarPath = `/api/repoAssignment/{repositoryId}/{userId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users assigned to a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling getAllAssignedUsers.');
            }
            const localVarPath = `/api/repoAssignment/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAssignment: async (assignmentTO: AssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentTO' is not null or undefined
            if (assignmentTO === null || assignmentTO === undefined) {
                throw new RequiredError('assignmentTO','Required parameter assignmentTO was null or undefined when calling updateUserAssignment.');
            }
            const localVarPath = `/api/repoAssignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof assignmentTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(assignmentTO !== undefined ? assignmentTO : {})
                : (assignmentTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepoAssignmentApi - functional programming interface
 * @export
 */
export const RepoAssignmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAssignment(assignmentTO: AssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentTO>> {
            const localVarAxiosArgs = await RepoAssignmentApiAxiosParamCreator(configuration).createUserAssignment(assignmentTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete user assignment to repository
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAssignment(repositoryId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepoAssignmentApiAxiosParamCreator(configuration).deleteUserAssignment(repositoryId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all users assigned to a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssignedUsers(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentTO>>> {
            const localVarAxiosArgs = await RepoAssignmentApiAxiosParamCreator(configuration).getAllAssignedUsers(repositoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserAssignment(assignmentTO: AssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentTO>> {
            const localVarAxiosArgs = await RepoAssignmentApiAxiosParamCreator(configuration).updateUserAssignment(assignmentTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RepoAssignmentApi - factory interface
 * @export
 */
export const RepoAssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAssignment(assignmentTO: AssignmentTO, options?: any): AxiosPromise<AssignmentTO> {
            return RepoAssignmentApiFp(configuration).createUserAssignment(assignmentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user assignment to repository
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment(repositoryId: string, userId: string, options?: any): AxiosPromise<void> {
            return RepoAssignmentApiFp(configuration).deleteUserAssignment(repositoryId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users assigned to a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers(repositoryId: string, options?: any): AxiosPromise<Array<AssignmentTO>> {
            return RepoAssignmentApiFp(configuration).getAllAssignedUsers(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAssignment(assignmentTO: AssignmentTO, options?: any): AxiosPromise<AssignmentTO> {
            return RepoAssignmentApiFp(configuration).updateUserAssignment(assignmentTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepoAssignmentApi - object-oriented interface
 * @export
 * @class RepoAssignmentApi
 * @extends {BaseAPI}
 */
export class RepoAssignmentApi extends BaseAPI {
    /**
     * 
     * @summary Create user assignment to repository
     * @param {AssignmentTO} assignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public createUserAssignment(assignmentTO: AssignmentTO, options?: any) {
        return RepoAssignmentApiFp(this.configuration).createUserAssignment(assignmentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user assignment to repository
     * @param {string} repositoryId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public deleteUserAssignment(repositoryId: string, userId: string, options?: any) {
        return RepoAssignmentApiFp(this.configuration).deleteUserAssignment(repositoryId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users assigned to a repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public getAllAssignedUsers(repositoryId: string, options?: any) {
        return RepoAssignmentApiFp(this.configuration).getAllAssignedUsers(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user assignment to repository
     * @param {AssignmentTO} assignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public updateUserAssignment(assignmentTO: AssignmentTO, options?: any) {
        return RepoAssignmentApiFp(this.configuration).updateUserAssignment(assignmentTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository: async (newRepositoryTO: NewRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newRepositoryTO' is not null or undefined
            if (newRepositoryTO === null || newRepositoryTO === undefined) {
                throw new RequiredError('newRepositoryTO','Required parameter newRepositoryTO was null or undefined when calling createRepository.');
            }
            const localVarPath = `/api/repo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof newRepositoryTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(newRepositoryTO !== undefined ? newRepositoryTO : {})
                : (newRepositoryTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling deleteRepository.');
            }
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/repo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManageableRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/repo/administration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling getSingleRepository.');
            }
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRepositories: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            if (typedName === null || typedName === undefined) {
                throw new RequiredError('typedName','Required parameter typedName was null or undefined when calling searchRepositories.');
            }
            const localVarPath = `/api/repo/search/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository: async (repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling updateRepository.');
            }
            // verify required parameter 'repositoryUpdateTO' is not null or undefined
            if (repositoryUpdateTO === null || repositoryUpdateTO === undefined) {
                throw new RequiredError('repositoryUpdateTO','Required parameter repositoryUpdateTO was null or undefined when calling updateRepository.');
            }
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof repositoryUpdateTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(repositoryUpdateTO !== undefined ? repositoryUpdateTO : {})
                : (repositoryUpdateTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepository(newRepositoryTO: NewRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).createRepository(newRepositoryTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).deleteRepository(repositoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).getAllRepositories(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManageableRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).getManageableRepositories(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).getSingleRepository(repositoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRepositories(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).searchRepositories(typedName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).updateRepository(repositoryId, repositoryUpdateTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(newRepositoryTO: NewRepositoryTO, options?: any): AxiosPromise<RepositoryTO> {
            return RepositoryApiFp(configuration).createRepository(newRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repositoryId: string, options?: any): AxiosPromise<void> {
            return RepositoryApiFp(configuration).deleteRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories(options?: any): AxiosPromise<Array<RepositoryTO>> {
            return RepositoryApiFp(configuration).getAllRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManageableRepositories(options?: any): AxiosPromise<Array<RepositoryTO>> {
            return RepositoryApiFp(configuration).getManageableRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository(repositoryId: string, options?: any): AxiosPromise<RepositoryTO> {
            return RepositoryApiFp(configuration).getSingleRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRepositories(typedName: string, options?: any): AxiosPromise<Array<RepositoryTO>> {
            return RepositoryApiFp(configuration).searchRepositories(typedName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): AxiosPromise<RepositoryTO> {
            return RepositoryApiFp(configuration).updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Repository
     * @param {NewRepositoryTO} newRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createRepository(newRepositoryTO: NewRepositoryTO, options?: any) {
        return RepositoryApiFp(this.configuration).createRepository(newRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Repository if you own it
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).deleteRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getAllRepositories(options?: any) {
        return RepositoryApiFp(this.configuration).getAllRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories that can be managed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getManageableRepositories(options?: any) {
        return RepositoryApiFp(this.configuration).getManageableRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Repository by providing its ID
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getSingleRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getSingleRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for repositories by name
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public searchRepositories(typedName: string, options?: any) {
        return RepositoryApiFp(this.configuration).searchRepositories(typedName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Repository
     * @param {string} repositoryId 
     * @param {RepositoryUpdateTO} repositoryUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any) {
        return RepositoryApiFp(this.configuration).updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareApi - axios parameter creator
 * @export
 */
export const ShareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/share/artifacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifacts: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling getSharedArtifacts.');
            }
            const localVarPath = `/api/share/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsByType: async (type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getSharedArtifactsByType.');
            }
            const localVarPath = `/api/share/artifacts/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get shared artifacts from repository by type
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsFromRepositoryByType: async (repositoryId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling getSharedArtifactsFromRepositoryByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getSharedArtifactsFromRepositoryByType.');
            }
            const localVarPath = `/api/share/repository/{repositoryId}/type/{type}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedRepositories: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling getSharedRepositories.');
            }
            const localVarPath = `/api/share/relations/repository/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository: async (shareWithRepositoryTO: ShareWithRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithRepositoryTO' is not null or undefined
            if (shareWithRepositoryTO === null || shareWithRepositoryTO === undefined) {
                throw new RequiredError('shareWithRepositoryTO','Required parameter shareWithRepositoryTO was null or undefined when calling shareWithRepository.');
            }
            const localVarPath = `/api/share/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof shareWithRepositoryTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(shareWithRepositoryTO !== undefined ? shareWithRepositoryTO : {})
                : (shareWithRepositoryTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithRepository: async (artifactId: string, repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            if (artifactId === null || artifactId === undefined) {
                throw new RequiredError('artifactId','Required parameter artifactId was null or undefined when calling unshareArtifactWithRepository.');
            }
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling unshareArtifactWithRepository.');
            }
            const localVarPath = `/api/share/repository/unshare/{artifactId}/{repositoryId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithRepository: async (shareWithRepositoryTO: ShareWithRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithRepositoryTO' is not null or undefined
            if (shareWithRepositoryTO === null || shareWithRepositoryTO === undefined) {
                throw new RequiredError('shareWithRepositoryTO','Required parameter shareWithRepositoryTO was null or undefined when calling updateShareWithRepository.');
            }
            const localVarPath = `/api/share/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof shareWithRepositoryTO !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(shareWithRepositoryTO !== undefined ? shareWithRepositoryTO : {})
                : (shareWithRepositoryTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareApi - functional programming interface
 * @export
 */
export const ShareApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSharedArtifacts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await ShareApiAxiosParamCreator(configuration).getAllSharedArtifacts(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedArtifacts(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await ShareApiAxiosParamCreator(configuration).getSharedArtifacts(repositoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedArtifactsByType(type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await ShareApiAxiosParamCreator(configuration).getSharedArtifactsByType(type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get shared artifacts from repository by type
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedArtifactsFromRepositoryByType(repositoryId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await ShareApiAxiosParamCreator(configuration).getSharedArtifactsFromRepositoryByType(repositoryId, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedRepositories(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SharedRepositoryTO>>> {
            const localVarAxiosArgs = await ShareApiAxiosParamCreator(configuration).getSharedRepositories(artifactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithRepositoryTO>> {
            const localVarAxiosArgs = await ShareApiAxiosParamCreator(configuration).shareWithRepository(shareWithRepositoryTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ShareApiAxiosParamCreator(configuration).unshareArtifactWithRepository(artifactId, repositoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithRepositoryTO>> {
            const localVarAxiosArgs = await ShareApiAxiosParamCreator(configuration).updateShareWithRepository(shareWithRepositoryTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ShareApi - factory interface
 * @export
 */
export const ShareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return ShareApiFp(configuration).getAllSharedArtifacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifacts(repositoryId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return ShareApiFp(configuration).getSharedArtifacts(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsByType(type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return ShareApiFp(configuration).getSharedArtifactsByType(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get shared artifacts from repository by type
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsFromRepositoryByType(repositoryId: string, type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return ShareApiFp(configuration).getSharedArtifactsFromRepositoryByType(repositoryId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedRepositories(artifactId: string, options?: any): AxiosPromise<Array<SharedRepositoryTO>> {
            return ShareApiFp(configuration).getSharedRepositories(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): AxiosPromise<ShareWithRepositoryTO> {
            return ShareApiFp(configuration).shareWithRepository(shareWithRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any): AxiosPromise<void> {
            return ShareApiFp(configuration).unshareArtifactWithRepository(artifactId, repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): AxiosPromise<ShareWithRepositoryTO> {
            return ShareApiFp(configuration).updateShareWithRepository(shareWithRepositoryTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareApi - object-oriented interface
 * @export
 * @class ShareApi
 * @extends {BaseAPI}
 */
export class ShareApi extends BaseAPI {
    /**
     * 
     * @summary Get all shared Artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getAllSharedArtifacts(options?: any) {
        return ShareApiFp(this.configuration).getAllSharedArtifacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Artifacts shared with Repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedArtifacts(repositoryId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedArtifacts(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedArtifactsByType(type: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedArtifactsByType(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get shared artifacts from repository by type
     * @param {string} repositoryId 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedArtifactsFromRepositoryByType(repositoryId: string, type: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedArtifactsFromRepositoryByType(repositoryId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories that can access a specific artifact (Admin permission required)
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedRepositories(artifactId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedRepositories(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share an artifact with all members of another repository
     * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any) {
        return ShareApiFp(this.configuration).shareWithRepository(shareWithRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the sharing-relation to a specific repository
     * @param {string} artifactId 
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any) {
        return ShareApiFp(this.configuration).unshareArtifactWithRepository(artifactId, repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the share-role of a relation with a repository
     * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any) {
        return ShareApiFp(this.configuration).updateShareWithRepository(shareWithRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of users by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleUsers: async (requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling getMultipleUsers.');
            }
            const localVarPath = `/api/user/multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof requestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(requestBody !== undefined ? requestBody : {})
                : (requestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the User that is currently sending requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/currentUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the namae of the user that is currently sending requests (name equals email address)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/registeredEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of users that matches the typed letters of a search
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            if (typedName === null || typedName === undefined) {
                throw new RequiredError('typedName','Required parameter typedName was null or undefined when calling searchUsers.');
            }
            const localVarPath = `/api/user/search/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).createUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of users by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultipleUsers(requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoTO>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getMultipleUsers(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns the User that is currently sending requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoTO>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUserInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns the namae of the user that is currently sending requests (name equals email address)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserName(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUserName(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a list of users that matches the typed letters of a search
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoTO>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).searchUsers(typedName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a new User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(options?: any): AxiosPromise<UserTO> {
            return UserApiFp(configuration).createUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of users by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleUsers(requestBody: Array<string>, options?: any): AxiosPromise<Array<UserInfoTO>> {
            return UserApiFp(configuration).getMultipleUsers(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the User that is currently sending requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<UserInfoTO> {
            return UserApiFp(configuration).getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the namae of the user that is currently sending requests (name equals email address)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName(options?: any): AxiosPromise<string> {
            return UserApiFp(configuration).getUserName(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of users that matches the typed letters of a search
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(typedName: string, options?: any): AxiosPromise<Array<UserInfoTO>> {
            return UserApiFp(configuration).searchUsers(typedName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Create a new User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(options?: any) {
        return UserApiFp(this.configuration).createUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of users by providing their Ids
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMultipleUsers(requestBody: Array<string>, options?: any) {
        return UserApiFp(this.configuration).getMultipleUsers(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the User that is currently sending requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfo(options?: any) {
        return UserApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the namae of the user that is currently sending requests (name equals email address)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserName(options?: any) {
        return UserApiFp(this.configuration).getUserName(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of users that matches the typed letters of a search
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public searchUsers(typedName: string, options?: any) {
        return UserApiFp(this.configuration).searchUsers(typedName, options).then((request) => request(this.axios, this.basePath));
    }
}


